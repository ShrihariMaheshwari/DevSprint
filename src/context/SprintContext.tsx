
import React, { createContext, useState, useContext, ReactNode } from 'react';

interface Sprint {
  id: string;
  name: string;
  goal: string;
  startDate: string;
  endDate: string;
}

interface DailyLog {
  id: string;
  sprintId: string;
  date: string;
  tasksCompleted: string[];
  blockers: string[];
  reflections: string;
}

interface WeeklySummary {
  week: string;
  content: string;
  generatedAt: string;
}

interface SprintContextType {
  sprints: Sprint[];
  currentSprint: Sprint | null;
  dailyLogs: DailyLog[];
  weeklySummaries: WeeklySummary[];
  addSprint: (sprint: Omit<Sprint, "id">) => void;
  setSprints: (sprints: Sprint[]) => void;
  setCurrentSprint: (sprint: Sprint | null) => void;
  addDailyLog: (log: Omit<DailyLog, "id">) => void;
  setDailyLogs: (logs: DailyLog[]) => void;
  generateWeeklySummary: () => Promise<string>;
  exportLogsToMarkdown: () => string;
  addWeeklySummary: (summary: WeeklySummary) => void;
  getWeeklySummary: (week: string) => WeeklySummary | null;
}

const SprintContext = createContext<SprintContextType | undefined>(undefined);

export const SprintProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [sprints, setSprints] = useState<Sprint[]>([]);
  const [currentSprint, setCurrentSprint] = useState<Sprint | null>(null);
  const [dailyLogs, setDailyLogs] = useState<DailyLog[]>([]);
  const [weeklySummaries, setWeeklySummaries] = useState<WeeklySummary[]>([]);

  const addSprint = (sprint: Omit<Sprint, "id">) => {
    const newSprint = {
      ...sprint,
      id: Date.now().toString(),
    };
    setSprints([...sprints, newSprint]);
    setCurrentSprint(newSprint);
  };

  const addDailyLog = (log: Omit<DailyLog, "id">) => {
    const newLog = {
      ...log,
      id: Date.now().toString(),
    };
    setDailyLogs([...dailyLogs, newLog]);
  };

  const generateWeeklySummary = async () => {
    // In a real implementation, this would call an API endpoint that uses OpenAI
    // For now, we'll simulate the summary generation
    
    const weekStart = new Date();
    weekStart.setDate(weekStart.getDate() - weekStart.getDay());
    
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    
    const weekString = `${weekStart.toLocaleDateString()} - ${weekEnd.toLocaleDateString()}`;
    
    // This would normally be generated by OpenAI based on the logs
    const summaryContent = `# Weekly Summary (${weekString})

## Accomplishments
- Implemented user authentication flow
- Created responsive dashboard
- Fixed 3 critical bugs in the checkout process
- Set up automated testing pipeline

## Challenges
- Struggled with API rate limits
- Had to refactor database schema midweek

## Insights
Based on your daily logs, you seem most productive in the mornings. Consider scheduling complex tasks during this period.

## Next Steps
- Complete the payment integration
- Improve error handling across the application
- Document API endpoints`;

    const newSummary = {
      week: weekString,
      content: summaryContent,
      generatedAt: new Date().toISOString(),
    };
    
    setWeeklySummaries([...weeklySummaries, newSummary]);
    
    return summaryContent;
  };

  const exportLogsToMarkdown = () => {
    let markdownContent = `# Sprint Logs Export\n\n`;
    
    sprints.forEach(sprint => {
      markdownContent += `## Sprint: ${sprint.name}\n`;
      markdownContent += `Goal: ${sprint.goal}\n`;
      markdownContent += `Duration: ${new Date(sprint.startDate).toLocaleDateString()} to ${new Date(sprint.endDate).toLocaleDateString()}\n\n`;
      
      const sprintLogs = dailyLogs.filter(log => log.sprintId === sprint.id);
      sprintLogs.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
      
      sprintLogs.forEach(log => {
        markdownContent += `### ${new Date(log.date).toLocaleDateString()}\n\n`;
        
        markdownContent += `#### Tasks Completed\n`;
        log.tasksCompleted.forEach(task => {
          markdownContent += `- ${task}\n`;
        });
        
        markdownContent += `\n#### Blockers\n`;
        if (log.blockers.length > 0) {
          log.blockers.forEach(blocker => {
            markdownContent += `- ${blocker}\n`;
          });
        } else {
          markdownContent += `- No blockers reported\n`;
        }
        
        markdownContent += `\n#### Reflections\n${log.reflections}\n\n`;
      });
    });
    
    return markdownContent;
  };

  const addWeeklySummary = (summary: WeeklySummary) => {
    setWeeklySummaries([...weeklySummaries, summary]);
  };

  const getWeeklySummary = (week: string) => {
    return weeklySummaries.find(summary => summary.week === week) || null;
  };

  return (
    <SprintContext.Provider
      value={{
        sprints,
        currentSprint,
        dailyLogs,
        weeklySummaries,
        addSprint,
        setSprints,
        setCurrentSprint,
        addDailyLog,
        setDailyLogs,
        generateWeeklySummary,
        exportLogsToMarkdown,
        addWeeklySummary,
        getWeeklySummary,
      }}
    >
      {children}
    </SprintContext.Provider>
  );
};

export const useSprint = () => {
  const context = useContext(SprintContext);
  if (context === undefined) {
    throw new Error('useSprint must be used within a SprintProvider');
  }
  return context;
};
